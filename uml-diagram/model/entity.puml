@startuml coffeBreak.entity

    skinparam class {
        BackgroundColor White
        BorderColor Black
        ArrowColor #444
        NoteBackgroundColor #F9F9F9
    }

    package entity {

        interface Entity <<interface>> {
            + {abstract} getPosition(): Position
            + {abstract} getDimension(): Dimension
            + {abstract} update(deltaTime: long): void
        }

        abstract class GameEntity <<abstract>> implements Entity {
            - position: Position
            - dimension: Dimension
            + {final} getPosition(): Position
            + {final} getDimension(): Dimension
            + {abstract} update(deltaTime: long): void
        }

        interface Movable <<interface>> {
            +{abstract} move(currentPosition: Position, direction: Vector2D): Position
        }

        interface PlayableCharacter <<interface>> {
            + {abstract} jump(): void
            + {abstract} loseLife(): void
        }

        class Mario extends GameEntity implements PlayableCharacter, Movable {
            - livesManager: LivesManager
            - scoreManager: GameScoreManager
            - currentState: MarioStateInterface
            - startPosition: Position
            - velocity: Vector2D
            - isOnGround: boolean
            + changeState(MarioState): void
            - changeState(MarioStateInterface): void
            + collectItem(Collectible): void
            + resetToInitialState(): void
            + isAlive(): boolean
        }

        Mario *-- LivesManager : manages
        Mario *-- MarioStateInterface : state

        class LivesManager {
            - {static} START_LIVES: int = 3
            - lives: int
            + loseLife(): void
            + reset(): void
            + getLives(): int
            + isGameOver(): boolean
        }

        interface Villain <<interface>> {
            + throwBarrel(): void
            + increaseAnger(): void
        }

        class DonkeyKong extends GameEntity implements Villain {
            - AngerManager angerManager
            - List~BarrelThrowObserver~ observers
            - CommandFactory commandFactory
            + getAngerLevel() int
            + registerObserver(BarrelThrowObserver) void
            + notifyObservers() void
        }

        class AngerManager {
            - level: int = 1
            - cooldowns: long[] = [5000, 3000, 1000]
            + increaseLevel() void
            + reset() void
            + getCurrentCooldown() long
        }

        interface Command {
            + execute(): void
        }

        class ThrowBarrelCommand implements Command {
            - villain: Villain
            + execute() void
        }

        class IncreaseAngerCommand implements Command {
            - villain: Villain
            + execute() void
        }

        interface CommandFactory {
            + createThrowCommand(): Command
            + createAngerCommand(): Command
        }

        class DonkeyCommandFactory implements CommandFactory{
            - donkeyKong: DonkeyKong
            + createThrowCommand() Command
            + createAngerCommand() Command
        }

        interface BarrelThrowObserver {
            + onBarrelTrow(): void
        }

        DonkeyKong *-- AngerManager
        DonkeyKong *-- CommandFactory: uses
        DonkeyKong o-- BarrelThrowObserver: notifies
        ThrowBarrelCommand --> Villain: executes on
        IncreaseAngerCommand --> Villain: executes on
        DonkeyKong --> Barrel : creates >
        BarrelManager --> DonkeyKong : uses

        interface Collectible <<interface>> {
            + {abstract} collect(): void
            + {abstract} getValue(): int
        }

        abstract class BaseCollectible <<abstract>> extends GameEntity implements Collectible {
            - value: int
            - state : CollectibleType
            + collect(): void
            + {abstract} getValue(): int
        }

        class Coin extends BaseCollectible
        class Hat extends BaseCollectible
        class Bag extends BaseCollectible
        class Hammer extends BaseCollectible {
            - duration: long
            + getRemainingTime(): long
        }

        interface Climbable <<interface>> {
            + {abstract} canClimb(): boolean
            + {abstract} getClimbSpeed(): float
        }

        class BasicLadder extends GameEntity implements Climbable {
            -DEFAULT_SPEED: float = 2.0
            -climbable: boolean = true
            +canClimb(): boolean
            +getClimbSpeed(): float
        }

        class LadderDecorator implements Climbable {
            - #wrapped: Climbable
            + canClimb(): boolean
            + getClimbSpeed(): float
        }

        class FastLadder extends LadderDecorator {
            -SPEED: float = 4.0
            +getClimbSpeed(): float <<override>>
        }

        class BrokenLadder extends LadderDecorator{
            +canClimb(): boolean <<override>>
        }

        interface Platform <<interface>> {
            + {abstract} canBreak(): boolean
            + {abstract} getFriction(): float
        }

        class BasicPlatform extends AbstractPlatform implements Platform {
            -DEFAULT_FRICTION: float = 0.5
            -breakable: boolean = false
            +canBreak(): boolean
            +getFriction(): float
        }

        abstract class PlatformDecorator <<abstract>> extends AbstractPlatform implements Platform {
            - # wrapped: Platform
            + {abstract} canBreak(): boolean
            + {abstract} getFriction(): float
        }

        class FragilePlatform extends PlatformDecorator {
            + canBreak(): boolean <<override: true>>
        }

        class MovingPlatform extends PlatformDecorator {
            -FRICTION: float = 0.7
            -velocity: Vector2D
            +getFriction(): float <<override>>
            +getVelocity(): Vector2D
            +update(deltaTime: long): void <<override>>
        }

        abstract class Enemy <<abstract>> extends GameEntity implements Movable {
            - EnemyType state
            - Vector2D velocity
            - Movable movementStrategy
            + update(long) void
            + move(Vector2D) void
        }

        class Barrel extends Enemy {
            - List~BarrelTransformationObserver~ transformationObservers
            - boolean canTransformToFire
            + addTransformationObserver(BarrelTransformationObserver) void
        }
        class Fire extends Enemy

        class BarrelMovementStrategy implements Movable {
            + move(Position, Vector2D) Position
        }

        class FireMovementStrategy implements Movable {
            + move(Position, Vector2D) Position
        }

        interface BarrelTransformationObserver {
            + onBarrelTransformedToFire(Barrel, Vector2D) void
        }
        Barrel *-- BarrelTransformationObserver

        class BarrelManager implements BarrelTransformationObserver {
            - List~Enemy~ activeEnemies
            + onBarrelTransformedToFire(Barrel, Vector2D) void
        }

        interface MarioStateInterface <<interface>> {
            + move(Mario, Vector2D): Position
            + jump(Mario): void
            + onStateEnter(Mario): void
            + onStateExit(Mario): void
        }

        abstract class AbstractMarioState implements MarioStateInterface
        
        class NormalState extends AbstractMarioState
        class WithHammerState extends AbstractMarioState
        class DeadState extends AbstractMarioState

        enum EnemyType {
            BARREL
            FIRE
            + createMovementStrategy() Movable
        }

        enum MarioState {
            NORMAL
            WITH_HAMMER
            DEAD
            + createState(Mario): AbstractMarioState
            + canTransitionTo(MarioState): boolean
        } 

        enum CollectibleType {
            COIN
            HAMMER
            HAT
            BAG
            EXTRA_LIFE
        }  
        
        note top of GameEntity
            == TEMPLATE METHOD PATTERN ==
            **Base Class for All Entities**:
            Fornisce implementazioni comuni per posizione/dimensioni
            lasciando ai sottotipi la definizione del comportamento update()

            **Caratteristiche**:
            • getPosition() e getDimension() sono final
            • update() rimane astratto per logica personalizzata

            **Vantaggi**:
            → Elimina duplicazione di codice
            → Fornisce struttura comune a tutte le entità
            → Permette variazioni controllate
        end note
        note top of Movable
            == STRATEGY PATTERN ==
            **Movimento Disaccoppiato**:
            Separa la logica di movimento dalle entità

            **Implementazioni**:
            • Personaggio giocabile (Mario)
            • Nemici (Barili, Fuoco)
            • Piattaforme mobili

            **Vantaggi**:
            → Possibilità di cambiare strategia di movimento a runtime
            → Logica di movimento riutilizzabile
            → Facile aggiunta di nuovi comportamenti
        end note
        note bottom of Mario
            == STATE PATTERN ==
            **Comportamento Dinamico**:
            Il comportamento di Mario cambia in base allo stato

            **Stati Principali**:
            • NORMAL: Mario base
            • WITHHAMMER: Può distruggere barili
            • DIE: Stato di morte

            **Transizioni**:
            ◄ NORMAL → WITHHAMMER (raccoglie martello)
            ◄ NORMAL → DIE (perde tutte le vite)

            **Vantaggi**:
            → Logica ben organizzata per stato
            → Facile aggiunta di nuovi stati
        end note
        note top of Collectible
            == FACTORY METHOD PATTERN ==
            **Creazione Oggetti Raccoglibili**:
            Gestisce la creazione di diversi tipi di collezionabili

            **Tipi Implementati**:
            • Coin: Aumenta punteggio
            • Hammer: Dà potere speciale
            • Hat/Bag: Bonus speciali

            **Vantaggi**:
            → Estensibile a nuovi tipi
            → Logica di raccolta centralizzata
            → Possibilità di pool di oggetti
        end note
        note top of Villain
            == COMMAND PATTERN ==
            **Azioni dei Nemici**:
            Incapsula le azioni dei personaggi antagonisti

            **Comandi Principali**:
            • throwBarrel(): Lancia barili
            • increaseAnger(): Aumenta aggressività

            **Vantaggi**:
            → Logica disaccoppiata
            → Possibilità di coda comandi
            → Facile undo per debug
        end note
        note bottom of DonkeyKong
            == OBSERVER PATTERN ==
            **Gestione Eventi**:
            Notifica cambiamenti di stato

            **Osservabili**:
            • angerLevel: Livello di rabbia
            • position: Posizione nel livello

            **Vantaggi**:
            → Reattività agli eventi di gioco
            → Disaccoppiamento tra componenti
            → Possibilità di multiple reazioni
        end note
        note top of LadderDecorator
            == DECORATOR PATTERN ==
            **Estensione Comportamento Scale**:
            Aggiunge funzionalità senza modificare le classi esistenti

            **Implementazioni**:
            • FastLadder: Scala veloce

            **Vantaggi**:
            → Composizione dinamica
            → Rispetto Open/Closed Principle
            → Combinabilità di decoratori
        end note        
        note top of PlatformDecorator
            == DECORATOR PATTERN ==
            **Piattaforme Modificabili**:
            Aggiunge caratteristiche speciali alle piattaforme

            **Varianti**:
            • FragilePlatform: Si rompe al contatto
            • MovingPlatform: Si muove orizzontalmente

            **Vantaggi**:
            → Estensibilità senza ereditarietà
            → Composizione a runtime
            → Codice più pulito e modulare
        end note

        note as N1
            **COLLABORAZIONE TRA PATTERN**
            
            == ARCHITETTURA COMPLETA ==
            1. [GameEntity] Fornisce struttura base a tutte le entità
            2. [Decorator] Aggiunge comportamenti speciali a scale/piattaforme
            3. [State] Gestisce i diversi stati di Mario e nemici
            4. [Observer] Monitora cambiamenti importanti
            5. [Strategy] Implementa diversi movimenti per entità
            6. [Command] Esegue azioni specifiche
            
            **BEST PRACTICES**:
            ► Separazione chiara tra logica e rendering
            ► Gestione stato centralizzata
            ► Eventi disaccoppiati tramite observer
        end note
        N1 .. GameEntity
    }
@enduml
